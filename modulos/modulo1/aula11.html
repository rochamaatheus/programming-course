<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Estilos principais -->
    <link rel="stylesheet" href="../../util/comumAula.css" />
    <!-- Estilos para o Prism.js -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />
    <!-- Script do Prism.js -->
    <script
      defer
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"
    ></script>
    <title>
      Aula 11: Criando um Jogo de Campo Minado em JavaScript para Terminal
    </title>
  </head>
  <body>
    <header>
      <h1>Criando um Jogo de Campo Minado em JavaScript para Terminal</h1>
    </header>
    <main>
      <div class="article-content">
        <a href="../../index.html" class="button"
          >Voltar para a P√°gina Principal</a
        >

        <!-- Descri√ß√£o -->
        <h2>Descri√ß√£o</h2>
        <p>
          Nesta aula, vamos aprender a criar um jogo de
          <span
            class="term"
            data-tooltip="Campo Minado √© um jogo onde o jogador deve revelar c√©lulas de um tabuleiro sem acertar uma mina."
            >Campo Minado</span
          >
          utilizando <code class="destaque">JavaScript</code> para ser executado
          no terminal. Este projeto nos ajudar√° a entender conceitos importantes
          como manipula√ß√£o de arrays, l√≥gica de programa√ß√£o, recurs√£o, Promises
          e intera√ß√£o com o usu√°rio via terminal.
        </p>

        <!-- Passo 1: Configura√ß√£o do Ambiente -->
        <h2>Passo 1: Configura√ß√£o do Ambiente</h2>
        <p>
          Antes de come√ßarmos a codificar, precisamos garantir que temos o
          ambiente configurado corretamente.
        </p>
        <ol>
          <li>
            <strong>Instale o Node.js:</strong> O Node.js permite que executemos
            JavaScript no terminal. Voc√™ pode baix√°-lo em
            <a href="https://nodejs.org" target="_blank">nodejs.org</a>.
          </li>
          <li>
            <strong>Editor de C√≥digo:</strong> Utilize um editor de c√≥digo de
            sua prefer√™ncia, como VSCode, Sublime Text ou Atom.
          </li>
          <li>
            <strong>Crie um Diret√≥rio para o Projeto:</strong> Organize seu
            projeto criando uma pasta espec√≠fica, por exemplo,
            <code class="destaque">campoMinado</code>.
          </li>
        </ol>

        <!-- Passo 2: Estrutura B√°sica do C√≥digo -->
        <h2>Passo 2: Estrutura B√°sica do C√≥digo</h2>
        <p>
          Vamos come√ßar criando a estrutura b√°sica do nosso jogo. Crie um
          arquivo chamado <code class="destaque">campoMinado.js</code> dentro do
          diret√≥rio do projeto e adicione o seguinte c√≥digo:
        </p>
        <div class="code-block">
          <button class="copy-button">Copiar</button>
          <pre><code class="language-javascript">
// Importa o m√≥dulo readline para interagir com o usu√°rio
const readline = require('readline');

// Fun√ß√£o principal que inicia o jogo
async function jogar() {
  // Configura√ß√£o da interface de leitura
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  // Fun√ß√£o para fazer perguntas de forma ass√≠ncrona
  const question = (str) => new Promise((resolve) => rl.question(str, resolve));

  // Encerrar a interface de leitura ao finalizar o jogo
  rl.close();
}

// Iniciar o jogo
jogar();
          </code></pre>
        </div>
        <p>
          Este c√≥digo configura a base para interagir com o usu√°rio no terminal
          usando o m√≥dulo <code class="destaque">readline</code> do Node.js.
          <span
            class="term"
            data-tooltip="Promises s√£o objetos que representam a eventual conclus√£o ou falha de uma opera√ß√£o ass√≠ncrona."
            >Promises</span
          >
          s√£o utilizados aqui para lidar com as entradas do usu√°rio de forma
          ass√≠ncrona.
        </p>

        <!-- Passo 3: Criando o Tabuleiro -->
        <h2>Passo 3: Criando o Tabuleiro</h2>
        <p>
          O tabuleiro √© representado por uma matriz bidimensional. Vamos criar
          uma fun√ß√£o para inicializar o tabuleiro com c√©lulas ocultas.
        </p>
        <div class="code-block">
          <button class="copy-button">Copiar</button>
          <pre><code class="language-javascript">
// Fun√ß√£o para criar o tabuleiro
function criarTabuleiro(tamanho) {
  const tabuleiro = Array.from({ length: tamanho }, () => Array(tamanho).fill('.'));
  return tabuleiro;
}

// Exemplo de uso
const tamanho = 5;
const tabuleiro = criarTabuleiro(tamanho);
console.log(tabuleiro);
          </code></pre>
        </div>
        <p>
          Neste exemplo, criamos um tabuleiro 5x5 preenchido com pontos
          <code class="destaque">.</code>, representando c√©lulas ocultas.
        </p>

        <!-- Passo 4: Posicionando as Minas -->
        <h2>Passo 4: Posicionando as Minas</h2>
        <p>
          Agora, vamos adicionar minas aleat√≥rias no tabuleiro. Para isso,
          utilizaremos a fun√ß√£o <code class="destaque">Math.random()</code> para
          gerar posi√ß√µes aleat√≥rias.
        </p>
        <div class="code-block">
          <button class="copy-button">Copiar</button>
          <pre><code class="language-javascript">
// Fun√ß√£o para criar o tabuleiro com minas
function criarTabuleiro(tamanho, minas) {
  const tabuleiro = Array.from({ length: tamanho }, () => Array(tamanho).fill('.'));
  const posicoesMinas = new Set();

  while (posicoesMinas.size < minas) {
    const x = Math.floor(Math.random() * tamanho);
    const y = Math.floor(Math.random() * tamanho);
    posicoesMinas.add(`${x},${y}`);
  }

  for (const pos of posicoesMinas) {
    const [x, y] = pos.split(',').map(Number);
    tabuleiro[x][y] = '*';
  }

  return { tabuleiro, posicoesMinas };
}

// Exemplo de uso
const tamanho = 5;
const minas = 5;
const { tabuleiro, posicoesMinas } = criarTabuleiro(tamanho, minas);
console.log(tabuleiro);
console.log(posicoesMinas);
          </code></pre>
        </div>
        <p>
          Aqui, utilizamos um <code class="destaque">Set</code> para garantir
          que as posi√ß√µes das minas sejam √∫nicas. As minas s√£o representadas
          pelo caractere <code class="destaque">*</code>.
        </p>
        <p>
          <span
            class="term"
            data-tooltip="Um Set √© uma estrutura de dados que armazena valores √∫nicos. Em JavaScript, ele √© usado para garantir que n√£o haja duplicatas."
            >Set</span
          >
          √© muito √∫til aqui para evitar que duas minas sejam colocadas na mesma
          posi√ß√£o.
        </p>

        <!-- Passo 5: Exibindo o Tabuleiro -->
        <h2>Passo 5: Exibindo o Tabuleiro</h2>
        <p>
          Vamos criar uma fun√ß√£o para exibir o tabuleiro no terminal, mostrando
          apenas as c√©lulas reveladas pelo jogador.
        </p>
        <div class="code-block">
          <button class="copy-button">Copiar</button>
          <pre><code class="language-javascript">
// Fun√ß√£o para exibir o tabuleiro
function mostrarTabuleiro(tabuleiro, revelado = null) {
  if (!revelado) {
    revelado = Array.from({ length: tabuleiro.length }, () => Array(tabuleiro.length).fill(false));
  }

  // Exibir √≠ndices das colunas
  process.stdout.write('\n   ');
  for (let i = 0; i < tabuleiro.length; i++) {
    process.stdout.write(` ${i} `);
  }
  console.log();

  // Exibir linhas com √≠ndices
  for (let i = 0; i < tabuleiro.length; i++) {
    process.stdout.write(` ${i} `);
    for (let j = 0; j < tabuleiro.length; j++) {
      if (revelado[i][j]) {
        process.stdout.write(` ${tabuleiro[i][j]} `);
      } else {
        process.stdout.write(' . ');
      }
    }
    console.log();
  }
}

// Exemplo de uso
const tamanho = 5;
const minas = 5;
const { tabuleiro, posicoesMinas } = criarTabuleiro(tamanho, minas);
const revelado = Array.from({ length: tamanho }, () => Array(tamanho).fill(false));
mostrarTabuleiro(tabuleiro, revelado);
          </code></pre>
        </div>
        <p>
          A fun√ß√£o <code class="destaque">mostrarTabuleiro</code> exibe o
          tabuleiro com √≠ndices de linha e coluna, mostrando apenas as c√©lulas
          reveladas. C√©lulas ocultas s√£o representadas por
          <code class="destaque">.</code>.
        </p>

        <!-- Passo 6: Contando Vizinhos -->
        <h2>Passo 6: Contando Vizinhos</h2>
        <p>
          Para cada c√©lula revelada, precisamos contar quantas minas est√£o ao
          seu redor. Isso ajudar√° o jogador a deduzir onde est√£o as minas.
        </p>
        <div class="code-block">
          <button class="copy-button">Copiar</button>
          <pre><code class="language-javascript">
// Fun√ß√£o para contar minas vizinhas
function contarVizinhos(tabuleiro, x, y) {
  const tamanho = tabuleiro.length;
  const direcoes = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],          [0, 1],
    [1, -1],  [1, 0],  [1, 1]
  ];
  let contador = 0;

  for (const [dx, dy] of direcoes) {
    const nx = x + dx;
    const ny = y + dy;
    if (nx >= 0 && nx < tamanho && ny >= 0 && ny < tamanho && tabuleiro[nx][ny] === '*') {
      contador++;
    }
  }
  return contador;
}

// Exemplo de uso
const x = 2;
const y = 2;
const vizinhos = contarVizinhos(tabuleiro, x, y);
console.log(`N√∫mero de minas ao redor de (${x}, ${y}): ${vizinhos}`);
          </code></pre>
        </div>
        <p>
          A fun√ß√£o <code class="destaque">contarVizinhos</code> verifica todas
          as oito posi√ß√µes adjacentes a uma c√©lula e conta quantas delas cont√™m
          minas.
        </p>

        <!-- Passo 7: Revelando C√©lulas -->
        <h2>Passo 7: Revelando C√©lulas</h2>
        <p>
          Quando o jogador escolhe uma c√©lula para revelar, precisamos atualizar
          o tabuleiro e, se a c√©lula n√£o tiver minas adjacentes, revelar
          recursivamente as c√©lulas vizinhas.
        </p>
        <div class="code-block">
          <button class="copy-button">Copiar</button>
          <pre><code class="language-javascript">
// Fun√ß√£o para revelar uma c√©lula
function revelar(tabuleiro, x, y, revelado) {
  if (revelado[x][y]) {
    return;
  }
  revelado[x][y] = true;

  if (tabuleiro[x][y] === '*') {
    return;
  }

  const vizinhos = contarVizinhos(tabuleiro, x, y);
  tabuleiro[x][y] = vizinhos > 0 ? vizinhos.toString() : ' ';

  if (vizinhos === 0) {
    const direcoes = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],          [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];
    for (const [dx, dy] of direcoes) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < tabuleiro.length && ny >= 0 && ny < tabuleiro.length) {
        revelar(tabuleiro, nx, ny, revelado);
      }
    }
  }
}

// Exemplo de uso
revelar(tabuleiro, 2, 2, revelado);
mostrarTabuleiro(tabuleiro, revelado);
          </code></pre>
        </div>
        <p>
          A fun√ß√£o <code class="destaque">revelar</code> marca a c√©lula como
          revelada, conta os vizinhos e, se n√£o houver minas ao redor, revela
          recursivamente as c√©lulas adjacentes.
        </p>
        <p>
          <span
            class="term"
            data-tooltip="Recurs√£o √© quando uma fun√ß√£o chama a si mesma para resolver subproblemas menores."
            >Recurs√£o</span
          >
          √© uma t√©cnica poderosa que utilizamos aqui para revelar todas as
          c√©lulas vazias adjacentes automaticamente.
        </p>

        <!-- Passo 8: Controle do Fluxo do Jogo -->
        <h2>Passo 8: Controle do Fluxo do Jogo</h2>
        <p>
          Agora, vamos integrar todas as fun√ß√µes anteriores para controlar o
          fluxo do jogo, interagindo com o jogador e determinando as condi√ß√µes
          de vit√≥ria ou derrota.
        </p>
        <div class="code-block">
          <button class="copy-button">Copiar</button>
          <pre><code class="language-javascript">
// Fun√ß√£o principal que inicia o jogo
async function jogar() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  // Fun√ß√£o para fazer perguntas de forma ass√≠ncrona usando Promises
  const question = (str) => new Promise((resolve) => rl.question(str, resolve));

  const tamanho = parseInt(await question('Digite o tamanho do tabuleiro (Ex: 5 para 5x5): '), 10);
  const minas = parseInt(await question('Digite o n√∫mero de minas: '), 10);

  const { tabuleiro, posicoesMinas } = criarTabuleiro(tamanho, minas);
  const revelado = Array.from({ length: tamanho }, () => Array(tamanho).fill(false));
  let fimDeJogo = false;

  while (!fimDeJogo) {
    mostrarTabuleiro(tabuleiro, revelado);
    try {
      const entrada = await question('Digite a posi√ß√£o para revelar (linha coluna): ');
      const [xStr, yStr] = entrada.trim().split(' ');
      const x = parseInt(xStr, 10);
      const y = parseInt(yStr, 10);

      if (isNaN(x) || isNaN(y) || x < 0 || x >= tamanho || y < 0 || y >= tamanho) {
        console.log('Entrada inv√°lida! Tente novamente.');
        continue;
      }

      if (posicoesMinas.has(`${x},${y}`)) {
        console.log('\nüí• Voc√™ atingiu uma mina! Fim de jogo.');
        fimDeJogo = true;
      } else {
        revelar(tabuleiro, x, y, revelado);
        const todasReveladas = tabuleiro.every((linha, i) =>
          linha.every((celula, j) => revelado[i][j] || celula === '*')
        );
        if (todasReveladas) {
          console.log('\nüéâ Parab√©ns! Voc√™ venceu!');
          fimDeJogo = true;
        }
      }
    } catch (error) {
      console.log('Ocorreu um erro! Tente novamente.');
    }
  }

  // Mostrar tabuleiro final
  mostrarTabuleiro(tabuleiro, Array.from({ length: tamanho }, () => Array(tamanho).fill(true)));
  rl.close();
}

// Iniciar o jogo
jogar();
          </code></pre>
        </div>
        <p>
          Neste trecho, controlamos o fluxo do jogo utilizando um loop
          <code class="destaque">while</code> que continua at√© que o jogador
          ven√ßa ou perca. Solicitamos entradas do usu√°rio, validamos as posi√ß√µes
          escolhidas e atualizamos o estado do jogo de acordo.
        </p>
        <p>
          <span
            class="term"
            data-tooltip="O m√©todo every() verifica se todos os elementos de um array satisfazem uma condi√ß√£o."
            >M√©todo every()</span
          >
          √© utilizado para verificar se todas as c√©lulas n√£o-minadas foram
          reveladas, determinando assim a vit√≥ria do jogador.
        </p>
        <p>
          <span
            class="term"
            data-tooltip="Promises s√£o objetos que representam a eventual conclus√£o ou falha de uma opera√ß√£o ass√≠ncrona."
            >Promises</span
          >
          s√£o fundamentais para lidar com opera√ß√µes ass√≠ncronas, como as
          entradas do usu√°rio, permitindo que o c√≥digo espere pelas respostas
          antes de prosseguir. Utilizamos
          <code class="destaque">async/await</code> para simplificar o uso de
          Promises, tornando o c√≥digo mais leg√≠vel e f√°cil de entender.
        </p>

        <!-- Ajustes e Melhorias -->
        <h2>Ajustes e Melhorias</h2>
        <p>
          Para tornar o jogo mais robusto e amig√°vel, realizamos alguns ajustes:
        </p>
        <ul>
          <li>
            <strong>Valida√ß√£o de Entrada:</strong> Garantimos que as entradas do
            usu√°rio sejam v√°lidas e dentro dos limites do tabuleiro.
          </li>
          <li>
            <strong>Exibi√ß√£o Final:</strong> Ao t√©rmino do jogo, exibimos o
            tabuleiro completo revelando todas as minas.
          </li>
          <li>
            <strong
              >Uso de <code class="destaque">Set</code> para Posi√ß√µes de
              Minas:</strong
            >
            Facilita a verifica√ß√£o r√°pida se uma posi√ß√£o cont√©m uma mina.
          </li>
          <li>
            <strong>Formata√ß√£o do Tabuleiro:</strong> Melhoramos a exibi√ß√£o do
            tabuleiro para uma visualiza√ß√£o mais clara no terminal.
          </li>
        </ul>

        <!-- C√≥digo Completo -->
        <h2>C√≥digo Completo</h2>
        <p>
          Abaixo est√° o c√≥digo completo do jogo de Campo Minado em JavaScript
          para terminal:
        </p>
        <div class="code-block">
          <button class="copy-button">Copiar</button>
          <pre><code class="language-javascript">
// Importa o m√≥dulo readline para interagir com o usu√°rio
const readline = require('readline');

// Fun√ß√£o para criar o tabuleiro com minas
function criarTabuleiro(tamanho, minas) {
  const tabuleiro = Array.from({ length: tamanho }, () => Array(tamanho).fill('.'));
  const posicoesMinas = new Set();

  while (posicoesMinas.size < minas) {
    const x = Math.floor(Math.random() * tamanho);
    const y = Math.floor(Math.random() * tamanho);
    posicoesMinas.add(`${x},${y}`);
  }

  for (const pos of posicoesMinas) {
    const [x, y] = pos.split(',').map(Number);
    tabuleiro[x][y] = '*';
  }

  return { tabuleiro, posicoesMinas };
}

// Fun√ß√£o para exibir o tabuleiro
function mostrarTabuleiro(tabuleiro, revelado = null) {
  if (!revelado) {
    revelado = Array.from({ length: tabuleiro.length }, () => Array(tabuleiro.length).fill(false));
  }

  // Exibir √≠ndices das colunas
  process.stdout.write('\n   ');
  for (let i = 0; i < tabuleiro.length; i++) {
    process.stdout.write(` ${i} `);
  }
  console.log();

  // Exibir linhas com √≠ndices
  for (let i = 0; i < tabuleiro.length; i++) {
    process.stdout.write(` ${i} `);
    for (let j = 0; j < tabuleiro.length; j++) {
      if (revelado[i][j]) {
        process.stdout.write(` ${tabuleiro[i][j]} `);
      } else {
        process.stdout.write(' . ');
      }
    }
    console.log();
  }
}

// Fun√ß√£o para contar minas vizinhas
function contarVizinhos(tabuleiro, x, y) {
  const tamanho = tabuleiro.length;
  const direcoes = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],          [0, 1],
    [1, -1],  [1, 0],  [1, 1]
  ];
  let contador = 0;

  for (const [dx, dy] of direcoes) {
    const nx = x + dx;
    const ny = y + dy;
    if (nx >= 0 && nx < tamanho && ny >= 0 && ny < tamanho && tabuleiro[nx][ny] === '*') {
      contador++;
    }
  }
  return contador;
}

// Fun√ß√£o para revelar uma c√©lula
function revelar(tabuleiro, x, y, revelado) {
  if (revelado[x][y]) {
    return;
  }
  revelado[x][y] = true;

  if (tabuleiro[x][y] === '*') {
    return;
  }

  const vizinhos = contarVizinhos(tabuleiro, x, y);
  tabuleiro[x][y] = vizinhos > 0 ? vizinhos.toString() : ' ';

  if (vizinhos === 0) {
    const direcoes = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],          [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];
    for (const [dx, dy] of direcoes) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < tabuleiro.length && ny >= 0 && ny < tabuleiro.length) {
        revelar(tabuleiro, nx, ny, revelado);
      }
    }
  }
}

// Fun√ß√£o principal que inicia o jogo
async function jogar() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  // Fun√ß√£o para fazer perguntas de forma ass√≠ncrona usando Promises
  const question = (str) => new Promise((resolve) => rl.question(str, resolve));

  const tamanho = parseInt(await question('Digite o tamanho do tabuleiro (Ex: 5 para 5x5): '), 10);
  const minas = parseInt(await question('Digite o n√∫mero de minas: '), 10);

  const { tabuleiro, posicoesMinas } = criarTabuleiro(tamanho, minas);
  const revelado = Array.from({ length: tamanho }, () => Array(tamanho).fill(false));
  let fimDeJogo = false;

  while (!fimDeJogo) {
    mostrarTabuleiro(tabuleiro, revelado);
    try {
      const entrada = await question('Digite a posi√ß√£o para revelar (linha coluna): ');
      const [xStr, yStr] = entrada.trim().split(' ');
      const x = parseInt(xStr, 10);
      const y = parseInt(yStr, 10);

      if (isNaN(x) || isNaN(y) || x < 0 || x >= tamanho || y < 0 || y >= tamanho) {
        console.log('Entrada inv√°lida! Tente novamente.');
        continue;
      }

      if (posicoesMinas.has(`${x},${y}`)) {
        console.log('\nüí• Voc√™ atingiu uma mina! Fim de jogo.');
        fimDeJogo = true;
      } else {
        revelar(tabuleiro, x, y, revelado);
        const todasReveladas = tabuleiro.every((linha, i) =>
          linha.every((celula, j) => revelado[i][j] || celula === '*')
        );
        if (todasReveladas) {
          console.log('\nüéâ Parab√©ns! Voc√™ venceu!');
          fimDeJogo = true;
        }
      }
    } catch (error) {
      console.log('Ocorreu um erro! Tente novamente.');
    }
  }

  // Mostrar tabuleiro final
  mostrarTabuleiro(tabuleiro, Array.from({ length: tamanho }, () => Array(tamanho).fill(true)));
  rl.close();
}

// Iniciar o jogo
jogar();
          </code></pre>
        </div>
        <p>
          Salve este c√≥digo no arquivo
          <code class="destaque">campoMinado.js</code> e execute-o no terminal
          usando o comando:
        </p>
        <pre><code class="destaque">node campoMinado.js</code></pre>
        <p>Agora voc√™ pode jogar o Campo Minado diretamente no seu terminal!</p>

        <!-- Conceitos Utilizados -->
        <h2>Conceitos Utilizados</h2>
        <ul>
          <li>
            <strong>Manipula√ß√£o de Arrays:</strong> Utilizamos arrays
            bidimensionais para representar o tabuleiro e o estado de revela√ß√£o.
          </li>
          <li>
            <strong>Recurs√£o:</strong> A fun√ß√£o
            <code class="destaque">revelar</code> utiliza recurs√£o para revelar
            c√©lulas adjacentes sem minas.
          </li>
          <li>
            <strong>Intera√ß√£o com o Usu√°rio:</strong> Usamos o m√≥dulo
            <code class="destaque">readline</code> do Node.js para receber
            entradas do usu√°rio no terminal.
          </li>
          <li>
            <strong>Estruturas de Dados Avan√ßadas:</strong> Utilizamos
            <code class="destaque">Set</code> para armazenar as posi√ß√µes das
            minas, garantindo unicidade.
          </li>
          <li>
            <strong>Controle de Fluxo:</strong> Implementamos loops e
            condicionais para controlar o fluxo do jogo.
          </li>
          <li>
            <strong>Promises:</strong> Utilizamos Promises para lidar com
            opera√ß√µes ass√≠ncronas, como as entradas do usu√°rio. Isso nos permite
            escrever c√≥digo ass√≠ncrono de maneira mais leg√≠vel e gerenci√°vel.
          </li>
          <li>
            <strong>Async/Await:</strong> Utilizamos
            <code class="destaque">async/await</code> para simplificar o uso de
            Promises, tornando o c√≥digo mais linear e f√°cil de entender.
          </li>
        </ul>

        <!-- Exerc√≠cios -->
        <h2>Exerc√≠cios</h2>
        <p>Pratique os conceitos aprendidos com os exerc√≠cios abaixo:</p>
        <ol>
          <li>
            <strong>Adicionar Marca√ß√£o de Bandeira:</strong>
            <p>
              Modifique o jogo para permitir que o jogador marque uma c√©lula com
              uma bandeira, indicando a suspeita de mina. Adicione comandos para
              alternar entre revelar e marcar c√©lulas.
            </p>
          </li>
          <li>
            <strong>Melhorar a Interface:</strong>
            <p>
              Aprimore a exibi√ß√£o do tabuleiro no terminal, utilizando cores
              para diferenciar c√©lulas reveladas, minas e bandeiras. Voc√™ pode
              utilizar sequ√™ncias de escape ANSI para cores.
            </p>
          </li>
          <li>
            <strong>Implementar uma Fun√ß√£o de Reset:</strong>
            <p>
              Adicione uma op√ß√£o para o jogador reiniciar o jogo ap√≥s o t√©rmino,
              sem precisar reiniciar o programa manualmente.
            </p>
          </li>
        </ol>

        <!-- Conclus√£o -->
        <h2>Conclus√£o</h2>
        <p>
          Neste tutorial, aprendemos a criar um jogo de Campo Minado em
          JavaScript para ser executado no terminal. Exploramos conceitos
          fundamentais como manipula√ß√£o de arrays, recurs√£o, intera√ß√£o com o
          usu√°rio, Promises e estruturas de dados avan√ßadas. Este projeto n√£o
          apenas refor√ßa sua compreens√£o de JavaScript, mas tamb√©m aprimora suas
          habilidades de l√≥gica e resolu√ß√£o de problemas.
        </p>
        <p>
          Continue praticando e explore novas funcionalidades para tornar seu
          jogo ainda mais completo e desafiador!
        </p>
      </div>
    </main>
    <footer>
      <p>&copy; 2024 Matheus Rocha</p>
    </footer>
    <!-- Scripts personalizados -->
    <script src="../../util/codeBlock.js"></script>
    <script src="../../util/backToTop.js"></script>
    <script src="../../util/tooltip.js"></script>
  </body>
</html>
